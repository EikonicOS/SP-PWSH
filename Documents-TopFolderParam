<#
Reports size and counts for TOP-LEVEL folders in the "Documents" library:
- SizeBytes: total of all files under that folder (recursive)
- FileCount: total files (recursive)
- SubfolderCount: total subfolders (recursive; excludes the folder itself)
- Shows Write-Progress (per folder) + macro counter [i/N]

Use -TopFolderName "Folder 1" to process only that top-level folder.

Requires:
  - PowerShell 7+ (pwsh)
  - Microsoft.Graph.Authentication
    Install-Module Microsoft.Graph.Authentication -Scope CurrentUser
#>

param(
  [string]$HostName    = "hashiragg.sharepoint.com",
  [string]$SitePath    = "sites/House",
  [string]$LibraryName = "Documents",
  [string]$OutputCsv   = "C:\Reports\Documents-TopFolders.csv",
  [string]$TopFolderName
)

$ErrorActionPreference = 'Stop'

# Core modules
Import-Module Microsoft.PowerShell.Utility -ErrorAction Stop
Import-Module Microsoft.PowerShell.Management -ErrorAction Stop

# Lightweight Graph auth only
if (-not (Get-Module -ListAvailable -Name Microsoft.Graph.Authentication)) {
  Write-Host "Installing Microsoft.Graph.Authentication..." -ForegroundColor Yellow
  Install-Module Microsoft.Graph.Authentication -Scope CurrentUser -Force -AllowClobber
}
Import-Module Microsoft.Graph.Authentication -ErrorAction Stop

# Connect (interactive if needed)
if (-not (Get-MgContext)) {
  Connect-MgGraph -Scopes 'Sites.Read.All','Files.Read.All' | Out-Null
}

# ---------- Helpers ----------
function Resolve-SiteId {
  param([string]$HostName, [string]$SitePath)
  $cleanSitePath = $SitePath.TrimStart('/')
  $byPathUri = "/v1.0/sites/${HostName}:/$cleanSitePath"
  try {
    $site = Invoke-MgGraphRequest -Method GET -Uri $byPathUri
    if ($site.id) { return $site.id }
  } catch {
    Write-Warning "Direct site path lookup failed (${HostName}:/$cleanSitePath). Falling back to search..."
  }
  $name = ($cleanSitePath.Split('/') | Select-Object -Last 1)
  $search = Invoke-MgGraphRequest -Method GET -Uri "/v1.0/sites?search=$name"
  $cand = $search.value | Where-Object { $_.webUrl -like "https://$HostName/*" } | Select-Object -First 1
  if ($cand) { return $cand.id }
  throw "Could not resolve site id for host '${HostName}' and path '$SitePath'."
}

function Get-ChildrenPaged {
  param([string]$DriveId, [string]$ItemId)
  $uri = "/v1.0/drives/$DriveId/items/$ItemId/children?`$top=999&`$select=id,name,folder,parentReference,size"
  while ($true) {
    $resp = Invoke-MgGraphRequest -Method GET -Uri $uri
    foreach ($c in $resp.value) { $c }
    $next = $resp.'@odata.nextLink'
    if (-not $next) { break }
    $uri = $next
  }
}

function Show-Progress {
  param(
    [string]$Activity,
    [int]$Processed,
    [int]$Discovered,
    [System.Diagnostics.Stopwatch]$Timer
  )
  $total    = [Math]::Max(1, $Discovered)
  $percent  = [Math]::Min(99, [int](($Processed / [double]$total) * 100))
  $elapsed  = $Timer.Elapsed
  $ips      = if ($elapsed.TotalSeconds -gt 0) { $Processed / $elapsed.TotalSeconds } else { 0 }
  $remain   = [Math]::Max(0, $Discovered - $Processed)
  $eta      = if ($ips -gt 0) { [TimeSpan]::FromSeconds($remain / $ips) } else { [TimeSpan]::Zero }
  $status   = "{0} | {1}/{2} items | {3}/s | Elapsed {4} | ETA {5}" -f `
              (Get-Date).ToString("HH:mm:ss"),
              $Processed, $Discovered,
              ([Math]::Round($ips,2)),
              $elapsed.ToString("hh\:mm\:ss"),
              $eta.ToString("hh\:mm\:ss")
  Write-Progress -Activity $Activity -Status $status -PercentComplete $percent
}

# ---------- Resolve site + library ----------
$siteId = Resolve-SiteId -HostName $HostName -SitePath $SitePath
$drives = Invoke-MgGraphRequest -Method GET -Uri "/v1.0/sites/$siteId/drives"
$drive  = $drives.value | Where-Object name -eq $LibraryName | Select-Object -First 1
if (-not $drive) { $available = ($drives.value.name -join ', '); throw "Library '$LibraryName' not found. Available: $available" }
$driveId = $drive.id

# Top-level folders
$topChildren = Invoke-MgGraphRequest -Method GET -Uri "/v1.0/drives/$driveId/root/children?`$top=999&`$select=id,name,folder,size"
$topFolders  = $topChildren.value | Where-Object { $_.folder -ne $null }

if (-not $topFolders) {
  Write-Host "No top-level folders found in '$LibraryName'." -ForegroundColor Yellow
  "" | Out-File -FilePath $OutputCsv
  Write-Host "Wrote empty CSV: $OutputCsv"
  return
}

# Filter to a single named top folder if requested
if ($TopFolderName) {
  $one = $topFolders | Where-Object { $_.name -ieq $TopFolderName } | Select-Object -First 1
  if (-not $one) { $one = $topFolders | Where-Object { $_.name -like $TopFolderName } | Select-Object -First 1 }
  if (-not $one) {
    $available = ($topFolders.name -join ', ')
    throw "Top-level folder '$TopFolderName' not found. Available: $available"
  }
  $topFolders = @($one)
}

# Macro counter
$totalFolders = $topFolders.Count
$folderIndex  = 0

# ---------- Scan ----------
$results = @()

foreach ($tf in $topFolders) {
  $folderIndex++
  $folderName = $tf.name
  $folderId   = $tf.id

  Write-Host ("[{0}/{1}] Scanning top-level folder: {2}" -f $folderIndex, $totalFolders, $folderName) -ForegroundColor Cyan

  $fileCount = 0
  $subfolderCount = 0
  [int64]$bytes = 0

  $stack = New-Object System.Collections.Stack
  $stack.Push($tf)

  $processed = 0
  $discovered = 1
  $sw = [System.Diagnostics.Stopwatch]::StartNew()
  $lastUpdate = [datetime]::MinValue

  while ($stack.Count -gt 0) {
    $current = $stack.Pop()
    $processed++

    $now = Get-Date
    if (($now - $lastUpdate).TotalMilliseconds -ge 200) {
      Show-Progress -Activity "Scanning '$folderName'..." -Processed $processed -Discovered $discovered -Timer $sw
      $lastUpdate = $now
    }

    if ($null -ne $current.folder) {
      if ($current.id -ne $folderId) { $subfolderCount++ }
      foreach ($child in Get-ChildrenPaged -DriveId $driveId -ItemId $current.id) {
        $discovered++
        if ($null -ne $child.folder) {
          $stack.Push($child)
        } else {
          $fileCount++
          $bytes += [int64]$child.size
        }
      }
    }
  }

  Write-Progress -Activity "Scanning '$folderName'..." -Completed
  $mb = [Math]::Round(($bytes / 1MB), 2)

  Write-Host ("{0} âœ“  Files: {1}, Subfolders: {2}, Size: {3} MB" -f $folderName,$fileCount,$subfolderCount,$mb) -ForegroundColor Gray

  $results += [pscustomobject]@{
    TopFolder       = $folderName
    FolderPath      = $folderName
    FileCount       = $fileCount
    SubfolderCount  = $subfolderCount
    SizeBytes       = $bytes
    SizeMB          = $mb
    SizeGB          = [Math]::Round(($bytes / 1GB), 4)
  }
}

# Export
$dir = Split-Path -Parent $OutputCsv
if (-not (Test-Path $dir)) { New-Item -Path $dir -ItemType Directory | Out-Null }
$results | Sort-Object SizeBytes -Descending | Export-Csv -Path $OutputCsv -NoTypeInformation -Encoding UTF8

Write-Host "Done. Wrote: $OutputCsv" -ForegroundColor Green
